/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "BrS8");
/******/ })
/************************************************************************/
/******/ ({

/***/ "600x":
/*!****************************!*\
  !*** ./src/js/myWallet.js ***!
  \****************************/
/*! dynamic exports provided */
/***/ (function(module, exports) {



// var apiURL = 'https://api.github.com/repositories/11730342/commits?per_page=5&sha=';
var apiURL = 'https://api.coinmarketcap.com/v1/ticker/';

// const vues = document.querySelectorAll(".wallet");

// const eachVue = Array.prototype.forEach;

// eachVue.call(vues, (el, index) => {
// new Vue({


new Vue({

    el: '#masterDashboard',
    // el,
    delimiters: ['${', '}'],

    data: {
        apies: ["https://api.coinmarketcap.com/v1/ticker/", "https://api.coinmarketcap.com/v1/ticker/dent/", "https://api.coinmarketcap.com/v1/ticker/pillar/", "https://api.coinmarketcap.com/v1/ticker/theta-token/"],

        globalMarket: "https://api.coinmarketcap.com/v1/global/",
        globalMarketCap: 0,
        bitcoinDominance: 0,
        total24HrVolume: 0,

        allCoins: [],

        // THIS HAS BEEN EXTRACTED TO PULL FROM A DATA ATTRIBUTE <data-holdings='{}'>
        // myHoldings: {},
        myMasterHoldings: {},

        myWallet: [],
        myMasterWallet: [],

        myWallets: [],

        myHoldingsTotalInUSD: 0,
        myHoldingsTotalInBTC: 0,

        fetchTick: 0,
        bitcoinPrice: 0,

        descrete: true
    },

    mounted: function mounted() {

        // Array.from(this.$el.getElementsByClassName("wallet")).forEach((w) => {
        //     this.prepWallet(w);
        // });

        // this.buildMyWallet();

        // var x = this.$el.getAttribute('data-holdings');
        // this.myHoldings = JSON.parse(x);
        //
        // console.log(this.myHoldings);

        this.fetchData();

        // setInterval(function () {
        //     this.fetchData();
        // }.bind(this), 60*10000);
    },

    computed: {
        calculateHoldings: function calculateHoldings(w) {
            return this.myWallet.reduce(function (total, c) {
                return total + c.holding_value;
            }, 0);
        }
    },

    filters: {
        formatUSD: function formatUSD(n) {
            return (n * 1).toFixed(2).replace(/(\d)(?=(\d{3})+\.)/g, '$1,');
        }
    },

    methods: {

        doneLoadingAllCoins: function doneLoadingAllCoins() {
            var _this = this;

            console.log('doneLoadingAllCoins()');
            /* THIS SHOULD BE RECODED TO WORK WITH MULTIPLE WALLETS */
            // this.myWallet = this.buildMyWallet(this.allCoins);
            // this.totalUSD();
            // this.totalBTC();
            // this.buildChart2();

            Array.from(this.$el.getElementsByClassName("wallet")).forEach(function (w) {
                _this.prepWallet(w);
            });

            // this.myWallets = Array.from(this.myWallets);
            // this.myWallets.forEach(w => this.buildMyWallet(w) );
            // console.log(this.myWallets);
        },

        prepWallet: function prepWallet(_w_) {
            // console.log('prepWallet', _w_);

            var holdings = _w_.getAttribute('data-holdings');
            // this.myHoldings = JSON.parse(x);

            // this.myMasterHoldings = Object.assign({}, JSON.parse(x));
            // console.log('myMasterHoldings', this.myMasterHoldings);


            //            let h = JSON.parse(holdings);

            //            console.log('holdings', holdings);
            //            console.log('h', h);

            // let w = { 'div':_w_, 'holding': this.buildMyWallet(h), 'holding_value':0 }
            // let w = { 'div':_w_ }
            // let w = this.buildMyWallet(w);


            // console.log(Array.from(this.myWallets));

            // this.buildMyWallet(w);


            var w = this.buildMyWallet(holdings);
            // console.log('w', w);


            // this.myWallets = Array.from(this.myWallets);
            // this.myWallets.forEach(w => this.buildMyWallet(w) );

            this.myWallets.push(w);
        },

        buildMyWallet: function buildMyWallet(_myCoins_) {
            console.log('buildmyWallet()', _myCoins_);
            console.log('this.allCoins', this.allCoins);

            return this.allCoins.filter(function (coin) {
                // WHAT IS THIS DOING?
                return Object.keys(_myCoins_).indexOf(coin.symbol) >= 0;

                // THIS ADDS NEW KEY:VALUE PAIRS TO THE COIN INFO.
            }).map(function (c) {
                return Object.assign({}, c, {
                    holding: _myCoins_[c.symbol],
                    holding_value: c.price_usd * _myCoins_[c.symbol]
                });

                // THIS WILL SORT FROM HIGHEST VALUE TO LOWEST VALUE.
            }).sort(function (a, b) {
                return a.holding_value - b.holding_value;
            }).reverse();
        },

        /*
                buildMyWallet: function(coins) {
                    // window.console.log('buildmyWallet()', this.myHoldings);
                    return coins.filter( coin => {
                        return Object.keys(this.myHoldings).indexOf(coin.symbol) >= 0;
                    }).map( c => {
                        return Object.assign({}, c, {
                            holding: this.myHoldings[c.symbol]
                            ,holding_value:  c.price_usd * (this.myHoldings[c.symbol] )
                        });
                    }).sort( (a, b) => {
                        return a.holding_value - b.holding_value;
                    }).reverse();
                },
         */

        formatAsUSD: function formatAsUSD(n) {
            return (n * 1).toFixed(2).replace(/(\d)(?=(\d{3})+\.)/g, '$1,');
        },

        coinClass: function coinClass(c) {
            var icon = void 0;
            switch (c) {
                case "EOS":
                case "ADA":
                case "RDD":
                case "OMG":
                case "SALT":
                    icon = c;
                    break;
                default:
                    icon = c + '-alt';
            }
            return icon;
        },

        fetchData: function fetchData() {

            var self = this;

            var status = function status(r) {
                if (r.ok) {
                    return r;
                } else {
                    throw new Error(r.statusText);
                }
            };

            var _json = function _json(r) {
                return r.json();
            };

            var promises = self.apies.map(function (url) {
                return fetch(url).then(_json);
            });

            Promise.all(promises).then(function (d) {
                // console.log('nice! now do something.', d);
                self.allCoins = d.reduce(function (acc, cur) {
                    return acc.concat(cur);
                }, []);

                // console.log('self.allCoins', self.allCoins);
                // self.myWallet = self.buildMyWallet(self.allCoins);
                // self.totalUSD();
                // self.totalBTC();
                // self.buildChart2();

                self.doneLoadingAllCoins();

                // console.log('myWallet', self.myWallet);

                // document.title = this.formatAsUSD(this.myHoldingsTotalInUSD);
            }).catch(function (e) {
                console.log('oops, something has gone wrong.', e);
            });

            fetch(self.globalMarket).then(function (response) {
                return response.json();
            }).then(function (myJSON) {
                self.bitcoinDominance = myJSON.bitcoin_percentage_of_market_cap;
                self.total24HrVolume = self.wordifyNumber(myJSON.total_24h_volume_usd);
                self.globalMarketCap = self.wordifyNumber(myJSON.total_market_cap_usd);
            });

            self.fetchTick++;
        },

        wordifyNumber: function wordifyNumber(n) {

            var incrementName = '';
            var num = void 0;

            if (Math.abs(Number(n)) >= 1.0e+15) {
                num = Math.abs(Number(n)) / 1.0e+15;
                incrementName = "Quadrillion";
            } else if (Math.abs(Number(n)) >= 1.0e+12) {
                num = Math.abs(Number(n)) / 1.0e+12;
                incrementName = "Trillion";
            } else if (Math.abs(Number(n)) >= 1.0e+9) {
                num = Math.abs(Number(n)) / 1.0e+9;
                incrementName = "Billion";
            } else if (Math.abs(Number(n)) >= 1.0e+6) {
                num = Math.abs(Number(n)) / 1.0e+6;
                incrementName = "Million";
            } else if (Math.abs(Number(n)) >= 1.0e+3) {
                num = Math.abs(Number(n)) / 1.0e+3;
                incrementName = "Thousand";
            } else {
                num = n;
                incrementName = "";
            }

            // let combinedAmount = (Math.round(parseFloat(num) * 10) / 10) + ' ' + incrementName;

            return Math.round(parseFloat(num) * 10) / 10 + ' ' + incrementName;
        },

        totalUSD: function totalUSD() {

            var N = this.myWallet.reduce(function (total, c) {
                return total + c.holding_value;
            }, 0);

            this.myHoldingsTotalInUSD = N;
        },

        totalBTC: function totalBTC() {
            // console.log('totalBTC()');
            this.bitcoinPrice = this.filterCoin("BTC")[0].price_usd;

            var n = Number(this.myHoldingsTotalInUSD) / Number(this.bitcoinPrice);
            // let n = this.myHoldingsTotalInUSD / this.bitcoinPrice ;

            // this.myHoldingsTotalInBTC = n;
            this.myHoldingsTotalInBTC = n.toFixed(6);

            // console.log( this.myHoldingsTotalInUSD, this.bitcoinPrice );

            // console.log( this.myHoldingsTotalInUSD );
            // console.log( this.myHoldingsTotalInBTC );
            // console.log( this.filterCoin("BTC"));
            // console.log( this.filterCoin("BTC")[0].price_usd );
        },

        filterCoin: function filterCoin(x) {
            var arr = this.allCoins.slice();
            return arr.filter(function (coin) {

                // return coin.id.indexOf(x) > -1;
                if (coin.symbol === x) {

                    return coin.symbol.indexOf(x) > -1;
                }
            });
        },

        /*
            BILLBOARD CHARTS
            https://naver.github.io/billboard.js/
         */
        buildChart2: function buildChart2(_thisWallet_) {
            // console.log('this.el', this.$el);
            // console.log('``` ', this.$el.querySelectorAll(".wallet") );

            // var thisWallet = this.$el;
            var thisWallet = _thisWallet_;
            var thisChart = thisWallet.querySelectorAll(".chart")[0];
            var thisLegend = thisWallet.querySelectorAll(".legend")[0];

            var chartData = [];
            // chartData = chartData.concat( this.myWallet.filter(coin => coin.holding > 0 ).map( coin => [coin.name, coin.holding_value] ) );
            chartData = chartData.concat(this.myWallet.filter(function (coin) {
                return coin.holding > 0;
            }).map(function (coin) {
                return [coin.name, coin.holding_value];
            }));
            // console.log('chartData', chartData);

            var chartTitle = "";
            // if (!this.descrete){
            // chartTitle = "$ " + String(this.formatAsUSD(this.myHoldingsTotalInUSD))+'\n \n'+String(this.myHoldingsTotalInBTC)+' BTC';
            // }

            var chart = bb.generate({
                // bindto: "#chart",
                bindto: thisChart,
                donut: {
                    title: chartTitle,
                    // padAngle: 0.01,
                    label: {
                        ratio: 1
                    }
                },
                legend: {
                    show: false,
                    position: "right"
                    // contents: {
                    // bindto: thisLegend,
                    // template: '<div style="color:#fff; padding:10px 15px; background-color:{=COLOR}">{=TITLE}</div>',
                    // },
                    // item: {
                    // onover: function(id) {
                    //     console.log(id);
                    //         d3.select(".bb-chart-arc.bb-target-"+ id +" text")
                    //         .style("fill-opacity", 1);
                    // },
                    // onout: function(id) {
                    //     console.log(id);
                    //         d3.select(".bb-chart-arc.bb-target-"+ id +" text")
                    //         .style("fill-opacity", 0);
                    // },
                    // onclick: function(id){
                    // THIS IS IN PLACE TO NULLIFY THE DEFAULT BEHAVIOR
                    // console.log(id);
                    // }
                    // }
                },
                data: {
                    type: "donut",
                    columns: chartData,
                    labels: false,
                    // labels: {
                    // format: function(v, id, i, j) {
                    // console.log('labels format something 1');
                    // console.log(v, id, i, j);
                    // },
                    // position does not seem to work:
                    // position: {
                    // x: 0,
                    // y: 0
                    // }
                    // },
                    colors: {
                        "Bitcoin": "#f9a021",
                        "Litecoin": "#b6b6b6",
                        "Ethereum": "#999999",
                        "OmiseGO": "#3979ff",
                        "EOS": "#9aa3ee",
                        "Populous": '#cfb949',
                        "ReddCoin": "#f01416",
                        "Veritaseum": "#ff991d",
                        "Pillar": "#00beff",
                        "Dent": "#af0000",
                        "Cardano": "#33c8c9"
                    }
                }
            });
        }

    }

});

// });

/***/ }),

/***/ "BrS8":
/*!************************!*\
  !*** ./src/js/site.js ***!
  \************************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__myWallet_js__ = __webpack_require__(/*! ./myWallet.js */ "600x");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__myWallet_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__myWallet_js__);
//
Vue.config.devtools = true;



/*
const svgEl = document.getElementById('svg-pie');
const slices = [
  { percent: 0.1, color: 'Coral' },
  { percent: 0.65, color: 'CornflowerBlue' },
  { percent: 0.2, color: '#00ab6b' },
  { percent: 0.01, color: 'green' },
];
let cumulativePercent = 0;

function getCoordinatesForPercent(percent) {
  const x = Math.cos(2 * Math.PI * percent);
  const y = Math.sin(2 * Math.PI * percent);
  return [x, y];
}

slices.forEach(slice => {
  // destructuring assignment sets the two variables at once
  const [startX, startY] = getCoordinatesForPercent(cumulativePercent);

  // each slice starts where the last slice ended, so keep a cumulative percent
  cumulativePercent += slice.percent;

  const [endX, endY] = getCoordinatesForPercent(cumulativePercent);

  // if the slice is more than 50%, take the large arc (the long way around)
  const largeArcFlag = slice.percent > .5 ? 1 : 0;

	// create an array and join it just for code readability
  const pathData = [
    `M ${startX} ${startY}`, // Move
    `A 1 1 0 ${largeArcFlag} 1 ${endX} ${endY}`, // Arc
    `L 0 0`, // Line
  ].join(' ');

  // create a <path> and append it to the <svg> element
  const pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  pathEl.setAttribute('d', pathData);
  pathEl.setAttribute('fill', slice.color);
  svgEl.appendChild(pathEl);



  pathEl.addEventListener("mouseenter", function( event ) {
      console.log('pathEl', pathEl);
  });

});
 */

/***/ })

/******/ });