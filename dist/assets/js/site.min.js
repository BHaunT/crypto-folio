/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "BrS8");
/******/ })
/************************************************************************/
/******/ ({

/***/ "600x":
/*!****************************!*\
  !*** ./src/js/myWallet.js ***!
  \****************************/
/*! dynamic exports provided */
/***/ (function(module, exports) {



// var apiURL = 'https://api.github.com/repositories/11730342/commits?per_page=5&sha=';
var apiURL = 'https://api.coinmarketcap.com/v1/ticker/';

/*
const vues = document.querySelectorAll(".wallet");
const eachVue = Array.prototype.forEach;
eachVue.call(vues, (el, index) => {
    new Vue({
 */

new Vue({

    el: '#wallet',
    // el,
    delimiters: ['${', '}'],

    data: {
        apies: ["https://api.coinmarketcap.com/v1/ticker/", "https://api.coinmarketcap.com/v1/ticker/dent", "https://api.coinmarketcap.com/v1/ticker/pillar"],
        allCoins: [],
        myHoldings: {
            // "BCH": 1,
            // "BTC": 2,
            // "LTC": 1,
            // "ETH": 1,
            // "PPT": 20,
            // "ADA": 500,
            // "OMG": 30,
            // "EOS": 130,
            // "RDD": 1800,
            // "SALT": 0,
            // "VERI": 2,
            // "PLR": 350
        },
        myWallet: [],
        myHoldingsTotalInUSD: 0,
        myHoldingsTotalInBTC: 0,
        fetchTick: 0,
        bitcoinPrice: 0

        // favorites:[
        //      {name:'Litecoin',  symbol: 'LTC', icon:'link/to/graphic', color:'red'}
        //     ,{name:'Ethereum',  symbol: 'ETH', icon:'link/to/graphic', color:'green'}
        //     ,{name:'EOS.io',    symbol: 'EOS', icon:'link/to/graphic', color:'blue'}
        // ]

    },

    mounted: function mounted() {

        var x = this.$el.getAttribute('data-holdings');
        this.myHoldings = JSON.parse(x);

        console.log(this.myHoldings);

        this.fetchData();

        setInterval(function () {
            this.fetchData();
        }.bind(this), 60 * 1000);
    },

    computed: {
        calculateHoldings: function calculateHoldings() {
            return this.myWallet.reduce(function (total, c) {
                return total + c.holding_value;
            }, 0);
        }
    },

    filters: {
        formatUSD: function formatUSD(n) {
            return (n * 1).toFixed(2).replace(/(\d)(?=(\d{3})+\.)/g, '$1,');
        }
    },

    methods: {
        formatAsUSD: function formatAsUSD(n) {
            return (n * 1).toFixed(2).replace(/(\d)(?=(\d{3})+\.)/g, '$1,');
        },

        coinClass: function coinClass(c) {
            var icon = void 0;
            switch (c) {
                case "EOS":
                case "ADA":
                case "RDD":
                case "OMG":
                case "SALT":
                    icon = c;
                    break;
                default:
                    icon = c + '-alt';
            }
            return icon;
        },

        fetchData: function fetchData() {
            var self = this;

            $.get(self.apies[0], function (response) {
                console.log(response);
                self.myWallet = self.buildMyWallet(response);
                self.totalUSD();
                self.totalBTC();
                // self.buildChart1();
                self.buildChart2();
            });

            self.fetchTick++;
        },

        totalUSD: function totalUSD() {

            var N = this.myWallet.reduce(function (total, c) {
                return total + c.holding_value;
            }, 0);

            // this.myHoldingsTotalInUSD = (N*1).toFixed(2).replace(/(\d)(?=(\d{3})+\.)/g, '$1,');
            this.myHoldingsTotalInUSD = N;

            console.log(this.myHoldingsTotalInUSD);
        },

        totalBTC: function totalBTC() {
            // console.log('totalBTC()');
            this.bitcoinPrice = this.filterCoin("BTC")[0].price_usd;

            var n = Number(this.myHoldingsTotalInUSD) / Number(this.bitcoinPrice);
            // let n = this.myHoldingsTotalInUSD / this.bitcoinPrice ;

            // this.myHoldingsTotalInBTC = n;
            this.myHoldingsTotalInBTC = n.toFixed(6);

            // console.log( this.myHoldingsTotalInUSD, this.bitcoinPrice );

            // console.log( this.myHoldingsTotalInUSD );
            console.log(this.myHoldingsTotalInBTC);
            // console.log( this.filterCoin("BTC"));
            // console.log( this.filterCoin("BTC")[0].price_usd );
        },

        buildMyWallet: function buildMyWallet(coins) {
            var _this = this;

            // window.console.log('buildmyWallet()', this.myHoldings);
            this.allCoins = coins;

            return coins.filter(function (coin) {
                // return Object.keys(this.myHoldings).indexOf(coin.id) >= 0;
                return Object.keys(_this.myHoldings).indexOf(coin.symbol) >= 0;
            }).map(function (c) {
                return Object.assign({}, c, {
                    // holding: this.myHoldings[c.id],
                    // holding_value:  c.price_usd * this.myHoldings[c.id]
                    holding: _this.myHoldings[c.symbol],
                    holding_value: c.price_usd * _this.myHoldings[c.symbol]

                });
            });
        },

        filterCoin: function filterCoin(x) {
            var arr = this.allCoins.slice();
            return arr.filter(function (coin) {

                // return coin.id.indexOf(x) > -1;
                if (coin.symbol === x) {

                    return coin.symbol.indexOf(x) > -1;
                }
            });
        },

        buildChart2: function buildChart2() {

            var chartData = [];

            chartData = chartData.concat(this.myWallet.filter(function (coin) {
                return coin.holding > 0;
            }).map(function (coin) {
                return [coin.name, coin.holding_value];
            }));

            // console.log('chartData', chartData);


            var chart = bb.generate({
                bindto: "#chart",
                donut: {
                    title: "$ " + String(this.formatAsUSD(this.myHoldingsTotalInUSD))
                },
                legend: {
                    show: true
                },
                data: {
                    type: "donut",
                    // columns: [
                    //     ["data1", 30, 200, 100, 170, 150, 250],
                    //     ["data2", 130, 100, 140, 35, 110, 50]
                    // ]
                    columns: chartData,
                    colors: {
                        "Bitcoin": "gold",
                        "Litecoin": "silver",
                        "Ethereum": "gray",
                        "OmiseGO": "lightblue",
                        "EOS": "purple"
                    }

                }
            });
        },

        /*
            GOOGLE CHART
         */
        buildChart1: function buildChart1() {

            console.log('buildChart()');

            google.charts.load("current", { packages: ["corechart"] });
            google.charts.setOnLoadCallback(drawChart);

            var myData = [['Coin', 'Percentage']];

            // console.log(this.myWallet);

            myData = myData.concat(this.myWallet.map(function (coin) {
                return [coin.name, coin.holding_value];
            }));

            console.log(myData);

            function drawChart() {

                var data = google.visualization.arrayToDataTable(myData);

                var options = {
                    // title: 'Crypto Play Wallet',
                    pieHole: 0.3
                    // ,is3D: true
                    // colors: ['red', 'blue', 'green', 'gold']
                    // ,legend: 'none'
                    , legend: {
                        alignment: 'center',
                        position: 'right'
                        // , maxLines:3

                        // ,pieStartAngle: 0
                        // ,slices: {  1: {offset: 0.2},
                        //             2: {offset: 0.3},
                        //             4: {offset: 0.4},
                        //             5: {offset: 0.5},
                        //         }
                    }, sliceVisibilityThreshold: .01
                };

                var chart = new google.visualization.PieChart(document.getElementById('chart1'));

                chart.draw(data, options);
            }
        }

    }

});

/*
});
 */

/***/ }),

/***/ "BrS8":
/*!************************!*\
  !*** ./src/js/site.js ***!
  \************************/
/*! no exports provided */
/*! all exports used */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__myWallet_js__ = __webpack_require__(/*! ./myWallet.js */ "600x");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__myWallet_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__myWallet_js__);
//
Vue.config.devtools = true;



/***/ })

/******/ });